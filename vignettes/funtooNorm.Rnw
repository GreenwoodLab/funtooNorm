\documentclass{article}
% \VignettePackage{funtooNorm}
% \VignetteIndexEntry{Normalization of Illumina Infinium HumanMethylation450 Beadchip data}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage{color}
\usepackage{underscore}
%\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}
\usepackage{verbatim}
%\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\usepackage{Sweave}%
% for bold symbols in mathmode
\usepackage{bm}
\usepackage{setspace}
\doublespacing

\SweaveOpts{keep.source=TRUE}

\title{Using funtooNorm}
\author{Celia Greenwood, Stepan Grinek, Kathleen Oros Klein}

\date{\today}
\sloppy
\hyphenpenalty 10000


\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle


%% Note: These are explained in '?RweaveLatex' :
%<<preliminaries, echo=FALSE>>=
%options(width=75)
%@

\section{Introduction}


The \texttt{funtooNorm} package provides  a function for normalization of Illumina Infinium Human Methylation 450 BeadChip (Illumina 450K) data when there are samples from multiple tissues or cell types. 
The algorithm in this package represents an extension of a normalization method introduced recently by
\cite{Fortin2014, Aryee2014}. 
In addition to the percentile-specific adjustments implemented in funNorm, funtooNorm is specifically designed to allow flexibility in the adjustments for different cell types or tissue types.  
Percentiles of methylation levels may vary across cell types and hence the original funNorm may not be ideal if applied to all samples simultaneously.  
Normalization separately for each cell type may introduce unwanted variability if sample sizes are small.
Therefore, this algorithm provides flexibility while optimizing the sample size used to estimate the corrections.

Note that the current version of the package does not do a good job of normalizing the Y chromosome probes; the funNorm method performs better.  
In a subsequent version of the package we will address this issue. 

\section{Package use}
\label{sec:package-use}

\subsection{Terminology}

As the \texttt{minfi} vignette describes nicely, the 450k array
contains two types of probes:
\begin{quote}
  CpGs measured using a Type I design are measured using a single
  color, with two different probes in the same color channel providing
  the methylated and the unmethylated measurements. CpGs measured
  using a Type II design are measured using a single probe, and two
  different colors provide the methylated and the unmethylated 
  measurements.
\end{quote}
Therefore, we dissociate the 6 types of signals in our method :
\texttt{AIGrn},  \texttt{BIGrn},  \texttt{AIRed},  \texttt{BIRed},  \texttt{AII}  and  \texttt{BII},
where the \textbf{A} (methylated) and \textbf{B} (unmethylated) are on \textbf{Green} or \textbf{Red} chanel depending \textbf{Type I} (Red or Green) and \textbf{Type II}. We will carefully talk about position when refering to a CpG and not about probe since the number of probe per position depend on the type of these position.


The \textbf{beta} value is computed with an offset of \texttt{100}
 like ILLUMINA standard but can be easily change.
 

  ... add something about the MValue ?? minfi propose it \[log(A \div B)\] ...
 
\subsection{Reading Data}

The package use a \texttt{SampleSet} on which you can apply functions.
It will contain your chip data and a matching cell type for each sample.
The first step will be to provide your data to a new \texttt{SampleSet}.
There is two way to load your data to the package. Using the output of \texttt{GenomeStudio}
or using raw \texttt{IDAT} files and use \texttt{minfi} package:
\begin{itemize}
  \item \texttt{GenomeStudio:} The function \texttt{fromGenStudFiles} take three arguments, the control probes file, the signal intensity file (we should add some specific information about gGenomeStudio if necessary here), and the cell_type vector.
  There is two way to pass your data to the package.
  \item \texttt{From IDAT:}  Using of \texttt{minfi} package, you should create a \texttt{RGChannelSet} object containing all your samples and use the function \texttt{fromRGChannelSet} to create your \texttt{SampleSet}. Please reffer to \texttt{minfi} vignette on how to create a \texttt{RGChannelSet}. The phenotype data of your object should contain a column name \texttt{cell_type}, you can access it via \texttt{pData()} .
  There must be at least two different cell or tissue types in the data or the program will terminate with a warning.
\end{itemize}

\subsection{DataSet}

We have provided a small data set containing $N=129$ samples from chip 450K to demonstrate the usage of the package. 
The samples are  from different types plasma cells.

 %The code to be inserted
%\begin{Verbatim}
<<>>= 
    #require(funtooNorm)
    require(matrixStats)
    require(pls)
    source("../R/SampleSet.R")
    source("../R/funtoonorm.R")
    load("testData.rda")
    #mySampleSet=fromRGChannelSet(ctrlFile,signalFile,cell_type)
    #mySampleSet

@
%\end{Verbatim}

Now you get the sampleSet ready for normalisation, you can already get the Beta value before normalization/

 %The code to be inserted
%\begin{Verbatim}
<<>>= 
    #origBeta <- getRawBeta(mySampleSet)
@
%\end{Verbatim}

Before normalizing you need to choose the ideal number of component for your data, we have set 4 as the default value for \texttt{ncmp}.

Choice of the number of components can be facilitated by examining a series of fits with different numbers of components : Calling the \texttt{plotValidationGraph} function with \texttt{type.fits = "PCR"} produces a set of plots, showing the root mean squared errors from cross-validated fits, for different numbers of components, SEPARATELY for each type of signal ("AIGrn" "BIGrn" "AIRed" "BIRed" "AII"  and "BII").  By looking at figures \ref{valPCR} the goal is to choose the smallest value of \texttt{ncmp} where the cross-validated root mean squared error is fairly small across the quantiles.
By default, funtooNorm will perform 10-fold cross-validation, but this can be changed with the parameter \texttt{ncv.fold}. You can set \texttt{type.fits = "validationcurve.pdf"} or change the type of fit to \texttt{"PLS"}
 %The code to be inserted
%\begin{Verbatim}
<<>>= 
    
    #plotValidationGraph(mySampleSet, type.fits="PCR")
@
%\end{Verbatim}

\begin{figure}[]
\centering
\includegraphics[width=10cm,height=10cm]{validationcurvesPCRlow.jpg}
\caption{Cross-validated root mean squared errors across percentiles of the signal distributions for different numbers of PCR components.  
Top: signal A; Bottom: signal B;  Left: probe type I red; Middle: probe type I green; Right: probe type II.} \label{valPCR}
\end{figure}

Here is a basic call to normalize this sample data set: 
funTooNorm will fit either principal component regression (PCR) or partial least squares regression (PLS) by specifying \texttt{type.fits="PCR"} or \texttt{type.fits="PLS"}.  The default is set to "PCR" to match funNorm. 
An important user-chosen parameter is  \texttt{ncmp}, the number of components to be included in either of these two models; these components are calculated from the control probe data and cell type data.

%\begin{Verbatim}
<<>>= 
    #This call  will perform cross validation to find optimal value 
    #of parameter ncmp for PLS regression:
    #mySampleSet=funTooNorm(mySampleSet,type.fits="PCR",ncmp=4)
    #mySampleSet
    #normBeta <- getNormBeta(mySampleSet)

@
%\end{Verbatim}

To assess the performance of normalization function one can use a measure of intra-replicate differences \texttt{M}, described in \cite{funtooNorm}. We provide a function \texttt{agreement} implementing this measure. It takes as arguments a matrix of beta values and a vector of individual ID's. For the function to work some elements of individual's vector, obviously, should be identical. The returned value of \texttt{M} is expected to be similar for the data before and after normalization:
%\begin{Verbatim}
<<>>= 
#agreement(origBeta, individualID) # M for data before the normalization
#agreement(normBeta, individualID)  # M for data after normalization
@
%\end{Verbatim} 
\section{FuntooNorm and the minfi package}


The \texttt{minfi} package~\cite{Aryee2014} contains several tools for
analyzing and visualizing Illumina's 450k array data. This section
shows the interoperability of this package with the
\texttt{funtooNorm} package.
<<>>=
library(minfi)
@


\subsection{Downstream use of the funtooNorm output}
Since normalization is rarely the final goal, this section shows how
to convert the output of \texttt{funtooNorm()} (the
\texttt{funtoonromout} object created in
section~\ref{sec:package-use}) to a \texttt{GenomicRatioSet} object, so
that it can be used by other tools in \texttt{minfi} like
\texttt{bumphunter()} or \texttt{blockFinder()}.

A \texttt{GenomicRatioSet} object requires some phenotype information,
so the following creates a \texttt{DataFrame}\footnote{The
  \texttt{DataFrame} class is part of the
  \href{http://www.bioconductor.org/packages/release/bioc/html/S4Vectors.html}{\texttt{S4Vectors}}
  package on Bioconductor, which is loaded by \texttt{minfi}} with
(random) gender information.
<<>>=
#phenoData <- DataFrame(Sample_Name=colnames(funtoonormout$newBeta),
#                       sex=sample(c("M", "F"), 93, replace=TRUE))
#rownames(phenoData) <- phenoData$Sample_Name

@

<<>>=
#includedProbes <- Annot[which(Annot$probe %in%
#                              rownames(funtoonormout$newBeta)),]
#genomerange <- GRanges(seqnames=includedProbes$probe,
#                       ranges=includedProbes$Mapinfo, strand=NA)

#grs <- GenomicRatioSet(gr=genomerange,
#                       Beta=funtoonormout$newBeta,
#                       preprocessMethod="funtooNorm",
#                       pData=phenoData)

@

The default print method of a \texttt{GenomicRatioSet} object shows
basic information of that object. In this example things were kept
simple in order to show the bare necessities.
<<>>=
#grs
@







library(minfiData)
\subsection{Using the example data from \texttt{minfi}}
Here we will show how to use the FuntooNorm functions on the
\texttt{RGsetEx} example data of the \texttt{minfi} package.

First, load the \texttt{minfiData} package that contains the example
data set.
<<>>=
library(minfiData)
@

The \texttt{IlluminaHumanMethylation450kmanifest} object contains
information on the array, which we need to extract various types of
information from.
<<>>=
pData(RGsetEx)$cell_type=rep(c("type1","type2"),3)
@

Information on the type of control probes on the array can be found
like this:
<<>>=
mySampleSet=fromRGChannelSet(RGsetEx)
@

Next, let's load the \texttt{RGsetEx} data set and have a look at the
summary of its contents:
<<>>=
mySampleSet
@


\begin{thebibliography}{}
\bibitem{Fortin2014} Fortin, J.-P., et al. (2014). Functional normalization of 450K methylation array data improves replication in large cancer studies. \emph{Genome Biology},  15: p. 503.
\bibitem{Aryee2014} Aryee, M.J., et al. (2014). Minfi: a flexible and comprehensive Bioconductor package for the analysis of Infinium DNA methylation microarrays. \emph{Bioinformatics}, 30(10): p. 1363-9.
\bibitem{Smith2013} Smith M., et al. (2013). illuminaio:  An open source  IDAT  parsing  tool  for  Illumina  microarrays. \emph{F1000Research}, 2:264, 2013.
\bibitem{funtooNorm}  Kathleen Oros Klein et al. (2015). \emph{funtooNorm:} An improvement of the funNorm normalization method for methylation data from multiple cell or tissue types.  Manuscript submitted.  

\end{thebibliography}
\end{document}
